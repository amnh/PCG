#include <set>#include <map>#include <string>#include <fstream>#include <iostream>using namespace std;	// will keep sorted lists of all grammars/structures a sentence is related tostruct sentData{	set<string> grammar;	set<string> structure;};	// i could have done without this function, but didn'tvoid addData( map<string, int>& stats, string sent, set<string>& count ){	stats[sent] = count.size();}void deleteTrailSpaces(string& sentence){	int length = sentence.length();	while( sentence[length - 1] == ' ')	{		sentence.erase(length - 1, 1);		length--;	}}void engJapStats(string sent, string& sMost, string& sLeast, int& most, int& least, int& total, set<string> group){	if( group.size() > most ) 	{		most = group.size();		sMost = sent;	}	if( group.size() < least )	{		least = group.size();		sLeast = sent;	}	total += group.size();}void doOutput( string which, string kind, int sTotal, int most, int least, int total, 				string sMost, string sLeast, ofstream& ofData ){	ofData << which << " has " << sTotal << " distinct sentences.\n";	ofData << "The average sentence has " << double(total) / double(sTotal) << " " << kind << ".\n";	ofData << "The sentence with the most " << kind << " is:\n";	ofData << sMost << "\n" << "which has " << most << " " << kind << ".\n";	ofData << "the sentence with the fewest " << kind << " is:\n" << sLeast << "\n";	ofData << "which has " << least << " " << kind << ".\n\n";}	void outputEngJapData( map<string, sentData>& stats, ofstream& ofData ){	map<string, sentData>::const_iterator mit = stats.begin();	int egMost = 0, egLeast = 5, egTotal = 0;	int esMost = 0, esLeast = 5, esTotal = 0;	int jgMost = 0, jgLeast = 5, jgTotal = 0;	int jsMost = 0, jsLeast = 5, jsTotal = 0;	int eSentTotal = 0, jSentTotal = 0;	string jsMostSent = "", jsLeastSent = "", esMostSent = "", esLeastSent = "";	string jgMostSent = "", jgLeastSent = "", egMostSent = "", egLeastSent = "";		for( ; mit != stats.end(); mit++ )	{		if( (*mit).second.grammar.find("0001001100011") != (*mit).second.grammar.end() )			// if in english		{			engJapStats( (*mit).first, egMostSent, egLeastSent, egMost, egLeast, egTotal, (*mit).second.grammar );			engJapStats( (*mit).first, esMostSent, esLeastSent, esMost, esLeast, esTotal, (*mit).second.structure );			eSentTotal ++;		}		else if( (*mit).second.grammar.find("0111100010000") != (*mit).second.grammar.end() )			// if in japanese		{			engJapStats( (*mit).first, jgMostSent, jgLeastSent, jgMost, jgLeast, jgTotal, (*mit).second.grammar );			engJapStats( (*mit).first, jsMostSent, jsLeastSent, jsMost, jsLeast, jsTotal, (*mit).second.structure );			jSentTotal ++;		}			}		doOutput( "English", "grammars", eSentTotal, egMost, egLeast, egTotal, egMostSent, egLeastSent, ofData );	doOutput( "English", "structures", eSentTotal, esMost, esLeast, esTotal, esMostSent, esLeastSent, ofData );		doOutput( "Japanese", "grammars", jSentTotal, jgMost, jgLeast, jgTotal, jgMostSent, jgLeastSent, ofData );	doOutput( "Japanese", "structures", jSentTotal, jsMost, jsLeast, jsTotal, jsMostSent, jsLeastSent, ofData );		}void outputStats( map<string, sentData>& stats, ostream& ofData ){	int gramTotal = 0, strucTotal = 0, jsLeast = 5, jsMost = 0, jgMost = 0, jgLeast = 5;	string sMost = "", sLeast= "", gMost = "", gLeast = "";		map<string, sentData>::const_iterator mit = stats.begin();	for( ; mit != stats.end(); mit++ )	{		if( ((*mit).second).grammar.size() == 1 )		{			ofData << (*mit).first << "\nAppears in only one grammar.\n";		}		if( ((*mit).second).structure.size() == 1 )		{			ofData << (*mit).first << "\nHas only one structure.\n";		}		if( ((*mit).second).structure.size() < jsLeast )		{			jsLeast = ((*mit).second).structure.size();			sLeast = (*mit).first;		}		else if( ((*mit).second).structure.size() > jsMost )		{			jsMost = ((*mit).second).structure.size();			sMost = (*mit).first;		}		if( ((*mit).second).grammar.size() < jgLeast )		{			jgLeast = ((*mit).second).grammar.size();			gLeast = (*mit).first;		}		else if( ((*mit).second).grammar.size() > jgMost )		{			jgMost = ((*mit).second).grammar.size();			gMost = (*mit).first;		}				gramTotal += ((*mit).second).grammar.size();		strucTotal += ((*mit).second).structure.size();	}		ofData << "There are a total of " << stats.size() << " sentences.\n";	ofData << "The sentence with the most structures has " << jsMost << "\n";	ofData << "and is: " << sMost << "\n";	ofData << "The sentence with the fewest structures has " << jsLeast << "\n";	ofData << "as is: " << sLeast << "\n";	ofData << "The sentence in the most grammars is in " << jgMost << " grammars\n";	ofData << "and is: " << gMost << "\n";	ofData << "The sentence in the fewest grammars is in " << jgLeast << " grammars\n";	ofData << "as is: " << gLeast << "\n";	ofData << "The average sentence has " << double(strucTotal) / double(stats.size() ) << " structures.\n";	ofData << "The average sentence appears in " << double(gramTotal) / double(stats.size() ) << " grammars.\n";}	int main(){	// /Volumes/Backup/eric/school/Thesis project/	// /home/eric/LD_data/			ifstream ifData ("/Volumes/Backup/eric/school/Thesis project/short.txt");	ofstream ofData ("/Volumes/Backup/eric/school/Thesis project/stats.txt");	string sentence, gramID, struc;	map<string, int> engStructs;			// keep track of english sentence structures	map<string, int> japStructs;			// japanese sentence structures	map<string, int> engGrams;				// how many grammars an english sentence belongs to	map<string, int> japGrams;				// same for japanese	map<string, sentData> compileStats;	// keeps track of overall stats on data		while (!ifData.eof() )	{		getline( ifData, gramID, '\t' );		getline( ifData, sentence, '\t' );		getline( ifData, struc, '\n' );				deleteTrailSpaces(sentence);				if (compileStats.find(sentence) == compileStats.end() )			// if the sentence has not yet been encountered		{			compileStats[sentence].grammar.insert(gramID);			compileStats[sentence].structure.insert(struc);		}		else if (gramID != "")			// it has been encountered, so increment either grammar or structure or both			// if is in case file ends with newline, and we get an extra, spurious gramID		{			if( (compileStats[sentence].grammar).find(gramID) !=				(compileStats[sentence].grammar).end() )					// grammar has been encountered, so must increment structure (both				 	// haven't been seen yet, or we wouldn't be encountering sentence here)			{				(compileStats[sentence].structure).insert(struc);			}			else // grammar not yet encountered, so incremement, then check for structure			{				(compileStats[sentence].grammar).insert(gramID);								if( (compileStats[sentence].structure).find(struc) !=					(compileStats[sentence].structure).end() )						// if structure not yet seen				{					(compileStats[sentence].structure).insert(struc);				} // note that if structure already seen, simply step through whole loop again			} // end else		} // end else			} // end while, now all data is in structures		// so compile data and print out	outputEngJapData( compileStats, ofData );	outputStats( compileStats, ofData );		}