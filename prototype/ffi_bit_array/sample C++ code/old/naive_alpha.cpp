// collects some basic statistics on the LD domain, regarding#include <set>#include <map>#include <string>#include <fstream>#include <iostream>#include <vector>using namespace std;// does what it saysvoid deleteTrailSpaces(string& sentence){	int length = sentence.length();	while( sentence[length - 1] == ' ')	{		sentence.erase(length - 1, 1);		length--;	}}// naiveAlpha computes (L_x intersect L_i) / L_x where L_x is a given grammar and puts it in a map structurevoid naiveAlpha( map<int, int>& sCount, map<int, int>& gCount, vector< vector<bool> >& sgMatrix, map<int, float>& naiAlph ){		// step through sentences, a grammar at a time	for( int gIndex = 0; gIndex < 8192; gIndex++ )	{		for( int sIndex = 0; sIndex < sgMatrix.size(); sIndex++ )		{			if( sgMatrix[sIndex][gIndex] == true )			{				naiAlph[gIndex] += float(sCount[sIndex]);				naiAlph[gIndex]--;				//cout << "true" << endl;			}			//else cout << "false" << endl;		}		naiAlph[gIndex] /= float(gCount[gIndex]);	}}void naiAlpPrint( map<int, float>& naiAlph, map<string, int>& gIndex, ofstream& naiveOut ){	string aa;	int bb;		for( map<string, int>::const_iterator it = gIndex.begin() ; it != gIndex.end(); it++ )	{			naiveOut << (*it).first << "\t" << naiAlph[ (*it).second ] << "\n";	}}			int main(){	// /Volumes/Backup/eric/school/Linguistics/LD with William/	// /home/eric/LD_data/			ifstream ifData ("/Volumes/Backup/eric/school/Linguistics/LD with William/ld.txt");	ofstream naiveOut ("/Volumes/Backup/eric/school/Linguistics/LD with William/naive_alpha.txt");		string sentence, gramID, struc;		map<string, int> sIndex; 	// to give each sentence a unique ID, for vector lookup	map<string, int> gIndex; 	// same as above, but for grammars	map<int, int> sCount; 	// keeps track of number of times each sentence has appeared in a unique grammar							// using the sentence ID as an index	map<int, int> gCount; 	// keeps track of unique sentences in each grammar, as above	map<int, float> naiAlph;	// to hold naive Alphas of each grammar		vector< vector<bool> > sgMatrix;	// to hold a matrix of bits saying whether a given sentence is in a grammar									// sgMatrix[1][2] would access sentence 1 in grammar 2		int sCurIndex = 0;	// keep track of current # of sentences	int gCurIndex = 0;	// same, but for grammars	bool gExists = false;  // this is for use in our nested if flowchart, below.						   // it lets us know if a given sentence is new to a grammar or not	bool sExists = false;	// as above, but for sentences		while (!ifData.eof() )	{		getline( ifData, gramID, '\t' );		getline( ifData, sentence, '\t' );		getline( ifData, struc, '\n' );				deleteTrailSpaces(sentence);					// firs see if grammar exists		if (gIndex.find(gramID) == gIndex.end() )			// if the grammar has not yet been encountered, first update 		{			gIndex[gramID] = gCurIndex;			gCurIndex++;				// since grammar didn't exist, we need to initialize it in gCount and make it 1			gCount[ (gIndex[gramID]) ] = 1;		}					else	// if grammar already existed, we need to note that, to know later whether to increment gCount		{			gExists = true;		}					// check to see if sentence has previously been encountered		if (sIndex.find(sentence) == sIndex.end() )		{			sIndex[sentence] = sCurIndex;			sCurIndex++;						// now add a new sentence to the matrix, with an empty grammar list			vector<bool> foo( 8192, false);			sgMatrix.push_back(foo);						sCount[ (sIndex[sentence]) ] = 1;		} 				else		{			sExists = true;			}// end if, now sentence and grammar are indexed. 						// now make the element of the matrix relating to this sentence/grammar true		if( sgMatrix[ (sIndex[sentence]) ][ (gIndex[gramID]) ] == false )		{			if( gExists == true )	// so they don't exist together, but it hasn't also just been initialized.			{				gCount[ (gIndex[gramID]) ]++;			}			if( sExists == true )			{				sCount[ (sIndex[sentence]) ]++;			}						sgMatrix[ (sIndex[sentence]) ][ (gIndex[gramID]) ] = true;		}				sExists = false;		gExists = false;				} // end while, now all data is in structures		 naiveAlpha( sCount, gCount, sgMatrix, naiAlph );	 naiAlpPrint( naiAlph, gIndex, naiveOut );}