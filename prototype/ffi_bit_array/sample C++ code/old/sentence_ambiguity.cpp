// reads from LD domain and count each individual sentence. Then normalizes counts and// prints to file sentence_ambiguity.txt#include <set>#include <map>#include <string>#include <fstream>#include <iostream>#include <vector>using namespace std;// does what it saysvoid deleteTrailSpaces(string& sentence){	int length = sentence.length();	while( sentence[length - 1] == ' ')	{		sentence.erase(length - 1, 1);		length--;	}}void outputSentences( map<int, int>& sCount, map<string, int>& sIndex, ofstream& sentenceAmb ){	for( map<string, int>::const_iterator it = sIndex.begin() ; it != sIndex.end(); it++ )	{			sentenceAmb << (*it).first << "\t" << float(sCount[ (*it).second ])/8192.0 << "\n";	}}			int main(){	// /Volumes/Backup/eric/school/Linguistics/LD with William/	// /home/eric/LD_data/	// /Users/eric/Documents/Backup/school/LD with william/			ifstream ifData ("/home/eric/LD_data/ld.txt");	ofstream sentenceAmb ("/home/eric/LD_data/sentence_ambiguity.txt");		string sentence, gramID, struc;		map<string, int> sIndex; 	// to give each sentence a unique ID, for vector lookup	map<string, int> gIndex; 	// same as above, but for grammars	map<int, int> sCount; 	// keeps track of number of times each sentence has appeared in a unique grammar							// using the sentence ID as an index	map<int, int> gCount; 	// keeps track of unique sentences in each grammar, as above		vector< vector<bool> > sgMatrix;	// to hold a matrix of bits saying whether a given sentence is in a grammar									// sgMatrix[1][2] would access sentence 1 in grammar 2		int gCurIndex = 0;	// keep track of current # of grammars	int sCurIndex = 0;	// keep track of current # of sentences		bool sExists = false;	// keeps track of whether sentence is new to loop or not		while (!ifData.eof() )	{		getline( ifData, gramID, '\t' );		getline( ifData, sentence, '\t' );		getline( ifData, struc, '\n' );				deleteTrailSpaces(sentence);					// check to see if sentence has previously been encountered		if (sIndex.find(sentence) == sIndex.end() )		{			sIndex[sentence] = sCurIndex;			sCurIndex++;						// now add a new sentence to the matrix, with an empty grammar list			vector<bool> foo( 8192, false);			sgMatrix.push_back(foo);						sCount[ (sIndex[sentence]) ] = 1;		} 					else // if you're here, sentence has already been encountered		{			sExists = true;			}// end if, now sentence and grammar are indexed. 						// now index grammar, for use in matrix		if (gIndex.find(gramID) == gIndex.end() ) 		{			gIndex[gramID] = gCurIndex;			gCurIndex++;		}				// now make the element of the matrix relating to this sentence/grammar true		if( sgMatrix[ (sIndex[sentence]) ][ (gIndex[gramID]) ] == false )		{			if( sExists == true )	//ie if sentence had been previously encountered, but grammar hadn't									// note that the if this is nested in is skipped if grammar/sentence combo 									// has been seen already			{				sCount[ (sIndex[sentence]) ]++;			}						sgMatrix[ (sIndex[sentence]) ][ (gIndex[gramID]) ] = true;		}				sExists = false;				} // end while, now all data is in structures		outputSentences( sCount, sIndex, sentenceAmb );}