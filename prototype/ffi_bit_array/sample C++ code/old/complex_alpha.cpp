// collects some basic statistics on the LD domain, regarding#include <set>#include <map>#include <string>#include <fstream>#include <iostream>#include <vector>using namespace std;// does what it saysvoid deleteTrailSpaces(string& sentence){	int length = sentence.length();	while( sentence[length - 1] == ' ')	{		sentence.erase(length - 1, 1);		length--;	}}	//computes (w(s)_L_x intersect w(s)_L_i) / w(s)_L_x, where L_x is a given grammar and w(s) is sentence weighting void ComplexAlpha( map<string, int>& sent_count, map<string, map<string, int> >& gram2sentence, ofstream& complexOut ){	int numerator = 0;	int denominator = 0;	// step through grammars, 	for( map<string, map<string, int> >::const_iterator it = gram2sentence.begin(); it != gram2sentence.end(); it++)	{		for( map<string, int>::const_iterator jt = (*it).second.begin(); jt != (*it).second.end(); jt++)		{			numerator += sent_count[(*jt).first];			numerator -= (*jt).second;			denominator += (*jt).second;		}		complexOut << (*it).first << "\t" << float(numerator) / float(denominator) << "\n";				numerator = 0;		denominator = 0;	}}// naiveAlpha computes (L_x intersect L_i) / L_x where L_x is a given grammar and puts it in a map structurevoid naiveAlpha( map<int, int>& sCount, map<int, int>& gCount, vector< vector<bool> > sgMatrix, map<int, float>& naiAlph ){		// step through sentences, a grammar at a time	for( int gIndex = 0; gIndex < 8192; gIndex++ )	{		for( int sIndex = 0; sIndex < sgMatrix.size(); sIndex++ )		{			if( sgMatrix[sIndex][gIndex] == true )			{				naiAlph[gIndex] += sCount[sIndex];				naiAlph[gIndex]--;			}		}		naiAlph[gIndex] /= float(gCount[gIndex]);	}}void naiAlpPrint( map<int, float>& naiAlph, map<string, int>& gIndex, ofstream& naiveOut ){	string aa;	int bb;		for( map<string, int>::const_iterator it = gIndex.begin() ; it != gIndex.end(); it++ )	{			naiveOut << (*it).first << "\t" << naiAlph[ (*it).second ] << "\n";	}}			int main(){	// /Volumes/Backup/eric/school/Linguistics/LD with William/	// /Users/eric/Documents/Backup/school/LD with William/	// /home/eric/LD_data/			ifstream ifData ("/Volumes/Backup/eric/school/Linguistics/LD with William/ld.txt");	ofstream complexOut ("/Volumes/Backup/eric/school/Linguistics/LD with William/complex_ambiguities.txt");		string sentence, gramID, struc;		map<string, int> sent_count;		// sorts sentences, remembers the grammars														// they appear in, and counts how many times each	map<string, map<string, int> > gram2sentence;		// maps all the sentences in a grammar to that grammar and 														// keeps track of how many times each appears in that grammar		while (!ifData.eof() )	{		getline( ifData, gramID, '\t' );		getline( ifData, sentence, '\t' );		getline( ifData, struc, '\n' );				deleteTrailSpaces(sentence);					// first see if sentence exists		if (sent_count.find(sentence) == sent_count.end() )			// if the sentence has not yet been encountered, add sentence to map 		{			sent_count[sentence] = 1;							if( gram2sentence.find(gramID) == gram2sentence.end() )		// add sentence to grammar			{				gram2sentence[gramID][sentence] = 1;			}								}					else	// if sentence already existed, we check to see if gram exists		{			sent_count[sentence]++;						if( gram2sentence.find(gramID) == gram2sentence.end() )				// then there is no gram			{				gram2sentence[gramID][sentence] = 1;			}			else 	// gram exists			{				if( (gram2sentence[gramID]).find(sentence) == (gram2sentence[gramID]).end() )				{		// then <gram, set> doesn't exist					gram2sentence[gramID][sentence] = 1;				}				else		// grammar and sentence existed together already				{					gram2sentence[gramID][sentence]++;				}			}			}				//cout << sentence << "\t" << sent_gram_count[sentence][gramID] << "\t" << sent_gram_count[sentence]["TOTAL"] << endl;	}		ComplexAlpha( sent_count, gram2sentence, complexOut );}