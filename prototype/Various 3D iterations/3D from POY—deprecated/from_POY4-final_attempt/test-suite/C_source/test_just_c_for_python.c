/** Uses a specific metazoa file and some files generated by Python code to select a series of random sequences to run through the C
 ** 3DO code. The code tested includes neither the Haskell interface nor the C-side interface to that Haskell code.
 **
 ** Extremely similar to debug_just_c.c, but this code is intended to be used with a Python script via the Python ffi,
 ** thus includes no main().
 **/

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>

#include "../../alignCharacters.h"
#include "../../alignmentMatrices.h"
#include "../../c_code_alloc_setup.h"
#include "../../debug_constants.h"
#include "../../ukkCheckPoint.h"
#include "../../ukkCommon.h"

// #define SEQ_CAPACITY 64

int power_2 (int input) {
    return (__builtin_popcount(input) == 1);
}

alignment_matrices_t *initializeNWMtx() {
    alignment_matrices_t *newMtx = malloc( sizeof(struct alignment_matrices_t) );

    // in six following allocations all matrices are set to their shortest length because they get realloced in mat_setup_size
    newMtx->cap_nw      = 0;  // a suitably small number to trigger realloc, but be larger than len_eff
    newMtx->cap_eff     = -1; // len_eff is -1 so that len_eff < len, triggering the realloc
    newMtx->cap_pre     = 0;  // again, trigger realloc

    newMtx->algn_costMtx    = malloc ( sizeof( int ) );
    newMtx->algn_dirMtx     = malloc ( sizeof( DIR_MTX_ARROW_t ) );
    // newMtx->pointers_3d  = malloc ( sizeof( int* ) );  // TODO: Why don't I have to dealloc all pointers in array?
    // newMtx->algn_costMtx3d  = malloc ( sizeof( int* ) );  // don't have to allocate these two,
    // newMtx->algn_dirMtx3d   = malloc ( sizeof( int* ) );  // because they're just pointing to nw_costMtx and dir_mtx_2d
    newMtx->algn_precalcMtx = malloc ( sizeof( int ) );

    return newMtx;
}


dyn_character_t *initializeSeq(size_t allocSize, const int *vals, size_t length) {
    dyn_character_t *retSeq = malloc( sizeof(struct dyn_character_t) );

    // assign sequence into sequence struct
    elem_t *seq = calloc(allocSize, sizeof(elem_t));
    if (length > 0) {
        for(size_t i = allocSize - length; i < allocSize; i++) {
            seq[i] = (int) vals[i - allocSize + length];
        }
    }

    // retSeq->magic_number = 0;         // This was only used in OCaml code
    retSeq->cap          = allocSize; // capacity
    retSeq->len          = length == 0 ? 0 : length;
    retSeq->array_head   = seq;
    retSeq->char_begin   = retSeq->array_head  + allocSize - retSeq->len; // because the assigned values are at the end of the array
    retSeq->end          = retSeq->char_begin + retSeq->len;

    return retSeq;
}

void freeSeq(dyn_character_t *toFree) {
    free(toFree->array_head);
    free(toFree);
}

void resetSeqValues(dyn_character_t *retSeq) {
    //retSeq->end   = retSeq->char_begin + retSeq->len;
    retSeq->char_begin = retSeq->end;
    retSeq->len        = 0;
}


// may return cost_matrices_2d or cost_matrices_3d, so void *
// no longer setting max, as algorithm to do so is unclear: see note below
void * setupCostMtx(unsigned int* tcm, int alphSize, int gap_open, int is_2d, dyn_character_t *longSeq) {
    // first allocate retMatrix
    int combinations = 1; // false if matrix is sparse. In this case, it's DNA, so not sparse.
    int do_aff       = gap_open == 0 ? 0 : 2; // The 2 is because affine's cost_model_type is 2, according to my reading of ML code.
                                              // This value set in cm_set_affine().
    int is_metric    = 1;
    int all_elements = 31; // How is this used?
    cost_matrices_2d_t *retMtx;

    int minCost2d = INT_MAX;
    int minCost3d = INT_MAX;
    // int maxCost = 0;
    elem_t median2d = 0, median3d = 0; // cumulative median for 2d and 3d; combos of median1, etc., below
    // int cost2d, cost3d;
    int curCost2d, curCost3d;

    int median1, median2, median3; // median of a given nucleotide and current ambElem, for each ambElem

    if (is_2d) {
        retMtx = malloc( sizeof(cost_matrices_2d_t) );
        cm_alloc_2d( retMtx
                   , alphSize
                   , combinations
                   , do_aff
                   , gap_open
                   , is_metric
                   , all_elements
                   );
    } else {
        retMtx = malloc( sizeof(cost_matrices_3d_t) );
        cm_alloc_3d( (cost_matrices_3d_t *) retMtx
                   , alphSize
                   , combinations
                   , do_aff
                   , gap_open
                   , all_elements
                   );
    }

    for (elem_t ambElem1 = 1; ambElem1 <= 31; ambElem1++) { // for every possible value of ambElem1, ambElem2, ambElem3
        for (elem_t ambElem2 = 1; ambElem2 <= 31; ambElem2++) {
            for (elem_t ambElem3 = 1; ambElem3 <= 31; ambElem3++) {
                curCost2d = curCost3d = 0; // don't actually need to do this
                minCost2d = INT_MAX;
                minCost3d = INT_MAX;
                // maxCost   = 0;
                median2d  = median3d = 0;
                median1   = median2  = median3 = 0;
                for (int nucleotide = 1; nucleotide <= alphSize; nucleotide++) {
                    // TODO: if we do maxCost, then we should find individual max's for each distance below?
                    curCost2d = distance (tcm, alphSize, nucleotide, ambElem1) +
                                distance (tcm, alphSize, nucleotide, ambElem2);
                    // now seemingly recreating logic in distance(), but that was to get the cost for each
                    // ambElem; now we're combining those costs get overall cost and median
                    if (curCost2d < minCost2d) {
                        minCost2d = curCost2d;
                        median2d  = 1 << (nucleotide - 1); // median1 | median2;
                    } else if (curCost2d == minCost2d) {
                        median2d |= 1 << (nucleotide - 1); // median1 | median2;
                    }
                    if (!is_2d) {
                        median1   = median2 = median3 = 0;
                        curCost3d = distance (tcm, alphSize, nucleotide, ambElem1) +
                                    distance (tcm, alphSize, nucleotide, ambElem2) +
                                    distance (tcm, alphSize, nucleotide, ambElem3);
                        if (curCost3d < minCost3d) {
                            minCost3d = curCost3d;
                            median3d  = 1 << (nucleotide - 1); // median1 | median2 | median3;
                            // if( power_2(ambElem1) && power_2(ambElem2) && power_2(ambElem3)) {
                            //     printf("<     seq1: %2d,    seq2: %2d,    seq3: %2d,    cost: %2d,    median: %2d,    nucleotide: %2d\n",
                            //       ambElem1, ambElem2, ambElem3, minCost3d, median3d, 1 << (nucleotide - 1));
                            // }
                        } else if (curCost3d == minCost3d) {
                            median3d |= 1 << (nucleotide - 1); // median1 | median2 | median3;
                            // if( power_2(ambElem1) && power_2(ambElem2) && power_2(ambElem3)) {
                            //     printf("==    seq1: %2d,    seq2: %2d,    seq3: %2d,    cost: %2d,    median: %2d,    nucleotide: %2d\n",
                            //       ambElem1, ambElem2, ambElem3, minCost3d, median3d, 1 << (nucleotide - 1));
                            // }
                        }
                    } // end 3d cost assignment
                } // nucleotide

                if (!is_2d) {
                    // printf("seq1: %d,    seq2: %d,    cost: %d,    median: %d\n",
                    //        ambElem1, ambElem2, minCost2d, median2d);
                    cm_set_cost_3d   ((cost_matrices_3d_t *) retMtx, ambElem1, ambElem2, ambElem3, minCost3d);
                    cm_set_median_3d ((cost_matrices_3d_t *) retMtx, ambElem1, ambElem2, ambElem3, median3d);
                    // cm_set_worst     (ambElem1, ambElem2, max_2d,    (cost_matrices_2d_t *) retMtx);    // no worst in 3d
                    // if( power_2(ambElem1) && power_2(ambElem2) && power_2(ambElem3)) {
                    //     printf("3d    seq1: %2d,    seq2: %2d,    seq3: %2d,    cost: %2d,    median: %2d\n",
                    //       ambElem1, ambElem2, ambElem3, minCost3d, median3d);
                    // }
                }
            } // ambElem3
            // printf("ambElem1:  %2hhu,   ambElem2: %2hhu\n", ambElem1, ambElem2);
            // printf("median: %2d,   min:   %2d\n", median2d, minCost2d);
            cm_set_cost_2d   ((cost_matrices_2d_t *) retMtx, ambElem1, ambElem2, minCost2d);
            cm_set_median_2d ((cost_matrices_2d_t *) retMtx, ambElem1, ambElem2, median2d);
            // if (power_2(ambElem1) && power_2(ambElem2)) {
            //     printf("2d    seq1: %d,    seq2: %d,    cost: %d,    median: %2d\n", ambElem1, ambElem2, minCost2d, median2d);
            // }
        } // ambElem2
    } // ambElem1
    if (is_2d) {
        elem_t* seqStart = longSeq->char_begin;
        int gap          = 1 << (alphSize - 1);
        int seqElem;
        for ( size_t i = 0; i < longSeq->len; i++) {
            // Gap number is alphSize - 1, which makes bit representation
            // i << (alphSize - 1), because first char value is i << 0.
            seqElem = (int) *(seqStart + i);
            cm_set_prepend_2d (retMtx, cm_get_cost_2d(retMtx, gap, seqElem), i);
            // printf("%2d", cm_get_cost(alphSize - 1, i, retMtx));
            cm_set_tail_2d    (retMtx, cm_get_cost_2d(retMtx, seqElem, gap), i);
        }
        printf("\n");
    }
    return retMtx;
}



/** First input is longest sequence, second is shortest. This order for use in 2D. **/
int wrapperFunction(int *firstSeq, int firstSeqLen, int *secondSeq, int secondSeqLen, int *thirdSeq, int thirdSeqLen) {


/******************************** set up and allocate all variables and structs ************************************/


/****************  Allocate sequences  ****************/

        //***** for following seqs, affine requires gap at start of sequence!!! *****/
    printf("length1: %d, length2: %d, length3: %d\n", firstSeqLen, secondSeqLen, thirdSeqLen);

    size_t alphSize = 5; // includes gap, but no ambiguities

    size_t total_poss_align_len = firstSeqLen + secondSeqLen + thirdSeqLen + 3;

    // These might not be actual long, medium and short seqs. But that should be sorted (literally sorted)
    // in c_alignment_interface.align3d
    dyn_character_t *longSeq   = initializeSeq(total_poss_align_len, firstSeq,  firstSeqLen);
    dyn_character_t *shortSeq  = initializeSeq(total_poss_align_len, secondSeq, secondSeqLen);
    dyn_character_t *mediumSeq = initializeSeq(total_poss_align_len, thirdSeq,  thirdSeqLen);

    dyn_character_t *retLongSeq   = initializeSeq(total_poss_align_len, 0, 0);
    dyn_character_t *retShortSeq  = initializeSeq(total_poss_align_len, 0, 0);
    dyn_character_t *retMediumSeq = initializeSeq(total_poss_align_len, 0, 0);



/****************  Allocate NW matrices  ****************/

    alignment_matrices_t *algn_mtxs2d       = initializeNWMtx();
    alignment_matrices_t *algn_mtxs2dAffine = initializeNWMtx();
    // alignment_matrices_t *algn_mtxs3d       = initializeNWMtx();



/************  Allocate cost matrices  **************/

    size_t tcm_total_len = alphSize * alphSize; // the size of the input tcm


    // !!!!! if modifying this code, also make sure to change is_metric !!!!!!
    unsigned int *tcm = calloc(tcm_total_len, sizeof(int)); // this is the input tcm, not the generated one
    for (size_t i = 0; i < tcm_total_len; i += alphSize) {
        //printf("i: %zu\n", i);
        for (size_t j = 0; j < alphSize; j++) {
            //printf("i: %zu, j: %zu, cost: %lu\n", i, j, 2 * i + 2 * j);
            //tcm[i + j] = 2 * i + 2 * j;
            if ( i == j * alphSize ) {
                // printf("i: %2zu, j: %2zu, cost: 0\n", i, j);
                tcm[i + j] = IDENTITY_COST;    // identity
            } else if (i == (tcm_total_len - alphSize) || j == (alphSize - 1)) {
                // printf("i: %2zu, j: %2zu, cost: 2\n", i, j);
                tcm[i + j] = INDEL_COST;   // indel cost
            } else {
                // printf("i: %2zu, j: %2zu, cost: 1\n", i, j);
                tcm[i + j] = SUB_COST;    // sub cost
            }
         }
    }




    cost_matrices_2d_t *costMtx2d;
    cost_matrices_2d_t *costMtx2d_affine;
    // cost_matrices_3d_t *costMtx3d;

    size_t n = alphSize;  // for "pretty printing" of tcm, below.

    // tcm is tcm; alphSize includes gap; third param is gap opening cost; fourth is is_2d
    if (DO_2D) {
        costMtx2d = setupCostMtx (tcm, alphSize, 0, 1, longSeq);
        algnMat_setup_size (algn_mtxs2d, longSeq->len, longSeq->len, costMtx2d->costMatrixDimension);
        n = costMtx2d->costMatrixDimension;
    }
    if (DO_AFF) {
        costMtx2d_affine = setupCostMtx (tcm, alphSize, GAP_OPEN_COST, 1, longSeq);
        algnMat_setup_size (algn_mtxs2dAffine, longSeq->len, longSeq->len, costMtx2d_affine->costMatrixDimension);
        n = costMtx2d_affine->costMatrixDimension;
    }
    // if (DO_3D) {
    //     costMtx3d = setupCostMtx (tcm, alphSize, 0, 0, longSeq);  // last argument means it's not 2d
    //     // penultimate parameter is ukk flag
    //     algnMat_setup_size (algn_mtxs3d, longSeq->len, mediumSeq->len, shortSeq->len, 0, costMtx3d->costMatrixDimension);
    //     n = costMtx3d->costMatrixDimension;
    // }
    int algnCost;


    // Print TCM in pretty format
    for (size_t i = 0; i < n; ++i) {
        for (size_t j = 0; j < n; ++j) {
            printf("%2d ", tcm[ n * i + j ]);
        }
        printf("\n");
    }


    // the following to compute deltawh, which increases the matrix height or width in algn_nw_2d
    // pulled from ML code
    // deltawh is for use in Ukonnen, it gives the current necessary width of the Ukk matrix
    int deltawh = 0;
    int diff = longSeq->len - shortSeq->len;
    int lower_limit = .1 * longSeq->len;
    if (deltawh) {
        deltawh = diff < lower_limit ? lower_limit : deltawh;
    } else {
        deltawh = diff < lower_limit ? lower_limit / 2 : 2;
    }
    if (DO_2D) {
        cm_print_2d (costMtx2d);
        cm_print_2d (costMtx2d_affine);
    }

    // cm_print_3d (costMtx3d);

/**************************************************** Do 2d alignment ********************************************************/

    if (DO_2D) {
        printf("\n\n\n******************** Align 2 sequences **********************\n");

        // printf("Original alignment matrix before algn_nw_2d: \n");
        // algn_print_dynmtrx_2d( longSeq, shortSeq, algn_mtxs2d );

        algnCost = algn_nw_2d( longSeq, shortSeq, costMtx2d, algn_mtxs2d, deltawh );

        if (DEBUG_MAT) {
            printf("\n\nFinal alignment matrix: \n\n");
            algn_print_dynmtrx_2d( longSeq, shortSeq, algn_mtxs2d );
        }


        printf("Original 2d sequences:\n");
        dyn_char_print(longSeq);
        dyn_char_print(shortSeq);

        algn_backtrace_2d (longSeq, shortSeq, retLongSeq, retShortSeq, algn_mtxs2d, costMtx2d, 0, 0, 1);
        printf("\nAligned 2d sequences\n");
        dyn_char_print(retLongSeq);
        dyn_char_print(retShortSeq);

        printf("Alignment cost: %d\n", algnCost);

        /****  Now get alignments  ****/

        printf("\nAligned sequences:\n");
        int *algnSeqVals = calloc(retLongSeq->len, sizeof(int));
        dyn_character_t *algnSeq = initializeSeq(total_poss_align_len, algnSeqVals, retLongSeq->len);
        free (algnSeqVals);
        resetSeqValues(algnSeq);

        // union:
        algn_union (retLongSeq, retShortSeq, algnSeq);
        printf("  Unioned sequence\n  ");
        dyn_char_print(algnSeq);

        // ungapped:
        resetSeqValues(algnSeq);
        algn_get_median_2d_no_gaps (retLongSeq, retShortSeq, costMtx2d, algnSeq);
        printf("\n  Median without gaps\n  ");
        dyn_char_print(algnSeq);

        // gapped:
        resetSeqValues(algnSeq);
        algn_get_median_2d_with_gaps (retLongSeq, retShortSeq, costMtx2d, algnSeq);
        printf("\n  Median with gaps\n  ");
        dyn_char_print(algnSeq);

        free (algnSeq);
    }



/************************************************ Do 2d affine alignment *****************************************************/

    /*** must have gap at start of sequence!!! ***/

    if (DO_AFF) {

        resetSeqValues(retLongSeq);
        resetSeqValues(retShortSeq);

        // TODO: document these variables
        // int *matrix;                        //
        unsigned int *close_block_diagonal;          //
        unsigned int *extend_block_diagonal;         //
        unsigned int *extend_vertical;               //
        unsigned int *extend_horizontal;             //
        unsigned int *final_cost_matrix;             //
        unsigned int *matrix_2d;          //
        unsigned int *gap_open_prec;                 // precalculated gap opening value (top row of nw matrix)
        unsigned int *s_horizontal_gap_extension;    //
        unsigned int *precalcMtx;           //
        int lenLongerSeq;                   //

        DIR_MTX_ARROW_t *direction_matrix;
        size_t lenLongSeq  = longSeq->len;
        size_t lenShortSeq = shortSeq->len;

        // reset return results
        resetSeqValues(retLongSeq);
        resetSeqValues(retShortSeq);

        lenLongerSeq = (lenLongSeq > lenShortSeq) ? lenLongSeq : lenShortSeq;

        //    mat_setup_size (algn_mtxs2dAffine, lenLongerSeq, lenLongerSeq, 0, 0, cm_get_lcm (costMtx2d_affine));
        matrix_2d  = algn_mtxs2dAffine->algn_costMtx;
        precalcMtx = algn_mtxs2dAffine->algn_precalcMtx;

        // TODO: figure out what the following seven values do/are
        //       also note the int factors, which maybe have something to do with the unexplained 12
        //       that appears in matrices.c?
        // here and in algn.c, "block" refers to a block of gaps, so close_block_diagonal is the cost to
        // end a subsequence of gaps, presumably with a substitution, but maybe by simply switching directions:
        // there was a vertical gap, now there's a horizontal one.
        close_block_diagonal       =  matrix_2d;
        extend_block_diagonal      = (matrix_2d + ( 2 * lenLongerSeq));
        extend_vertical            = (matrix_2d + ( 4 * lenLongerSeq));
        extend_horizontal          = (matrix_2d + ( 6 * lenLongerSeq));
        final_cost_matrix          = (matrix_2d + ( 8 * lenLongerSeq));
        gap_open_prec              = (matrix_2d + (10 * lenLongerSeq));
        s_horizontal_gap_extension = (matrix_2d + (11 * lenLongerSeq));



        // TODO: empty_medianSeq might not be necessary, as it's unused in ml code:
        size_t medianSeqLen = lenLongSeq + lenShortSeq + 2;  // 2 because that's how it is in ML code

        dyn_character_t *empty_medianSeq = malloc( sizeof(dyn_character_t) );
        empty_medianSeq->cap             = medianSeqLen;
        empty_medianSeq->array_head      = calloc( medianSeqLen, sizeof(elem_t));
        empty_medianSeq->len             = 0;
        empty_medianSeq->char_begin      = empty_medianSeq->end = empty_medianSeq->array_head + medianSeqLen;

        dyn_character_t *medianSeq = malloc( sizeof(dyn_character_t) );
        medianSeq->cap             = medianSeqLen;
        medianSeq->array_head      = calloc( medianSeqLen, sizeof(elem_t));
        medianSeq->len             = 0;
        medianSeq->char_begin      = medianSeq->end = medianSeq->array_head + medianSeqLen;

        direction_matrix = algn_mtxs2dAffine->algn_dirMtx;

        printf("\n\n\n***************** Align 2 sequences affine ********************\n\n");

        printf("Original affine 2d sequences:\n");

        // dyn_character_t *longerSequence = lenLongSeq > lenShortSeq ? longSeq : shortSeq;
        // dyn_character_t *shorterSequence = lenLongSeq > lenShortSeq ? shortSeq : longSeq;

        dyn_char_print(longSeq);
        dyn_char_print(shortSeq);

        algnMtx_precalc_4algn_2d( algn_mtxs2dAffine, costMtx2d_affine, longSeq );

        // TODO: consider moving all of this into algn.
        //       the following three fns were initially not declared in algn.h
        algn_initialize_matrices_affine( costMtx2d_affine->gap_open_cost
                                       , shortSeq
                                       , longSeq
                                       , costMtx2d_affine
                                       , close_block_diagonal
                                       , extend_block_diagonal
                                       , extend_vertical
                                       , extend_horizontal
                                       , final_cost_matrix
                                       , direction_matrix
                                       , precalcMtx
                                       );

        if (DEBUG_AFFINE) {
            printf("\n");
            printf("close_block_diagonal      : %d\n", *close_block_diagonal      );
            printf("extend_block_diagonal     : %d\n", *extend_block_diagonal     );
            printf("extend_vertical           : %d\n", *extend_vertical           );
            printf("extend_horizontal         : %d\n", *extend_horizontal         );
            printf("final_cost_matrix         : %d\n", *final_cost_matrix         );
            printf("gap_open_prec             : %d\n", *gap_open_prec             );
            printf("s_horizontal_gap_extension: %d\n", *s_horizontal_gap_extension);
            printf("\n");
        }

       // for (int *i = matrix_2d, j = 0; i < matrix_2d + algn_mtxs2dAffine->len; i++, j++) {
       //     printf("%d, ", *i);
       //     if (j % (lenLongerSeq ) == 0) {
       //         printf("\n");
       //     }
       // }


        // shorter first
        // TODO: why isn't this argument order consistent with next fn call?
        algnCost = algn_fill_plane_2d_affine( shortSeq
                                            , longSeq
                                            , shortSeq->len - 1
                                            , longSeq->len - 1
                                            , final_cost_matrix
                                            , direction_matrix
                                            , costMtx2d_affine
                                            , extend_horizontal
                                            , extend_vertical
                                            , close_block_diagonal
                                            , extend_block_diagonal
                                            , precalcMtx
                                            , gap_open_prec
                                            , s_horizontal_gap_extension
                                            );



        if (DEBUG_MAT) {
            printf("\n\nFinal alignment matrix, affine: \n\n");
            algn_print_dynmtrx_2d( longSeq, shortSeq, algn_mtxs2dAffine );
        }


        // shorter first
        // TODO: fix this to make it consistent
        algn_backtrace_affine( longSeq
                             , shortSeq
                             , direction_matrix
                             , medianSeq
                             , empty_medianSeq
                             , retLongSeq
                             , retShortSeq
                             , costMtx2d_affine
                             );

        printf("\nAligned affine 2d sequences\n");
        if (lenLongSeq > lenShortSeq) {
          dyn_char_print(retShortSeq);
          dyn_char_print(retLongSeq);
          printf("median Seq:\n");
          dyn_char_print(medianSeq);
        } else {
          dyn_char_print(retLongSeq);
          dyn_char_print(retShortSeq);
          printf("median Seq:\n");
          dyn_char_print(medianSeq);
        }

        freeSeq(empty_medianSeq);
        freeSeq(medianSeq);

        printf("\nAlignment cost: %d\n", algnCost);
    }


/************************************************ Do 3d alignment *************************************************/

    if (DO_3D) {

        printf("\n\n\n******************** Align 3 sequences **********************\n\n");

        // must first reset values in retLongSeq and retShortSeq
        resetSeqValues(retLongSeq);
        resetSeqValues(retShortSeq);

        // algnCost = algn_nw_3d (longSeq, mediumSeq, shortSeq, costMtx3d, algn_mtxs3d, deltawh);
        // printf("Final alignment matrix: \n");
        // algn_print_dynmtrx_2d_2d( longSeq, shortSeq, algn_mtxs3d );

        printf("Original 3d sequences:\n");
        dyn_char_print(longSeq);
        dyn_char_print(mediumSeq);
        dyn_char_print(shortSeq);
        printf("\n");

        // short input, medium input, long input
        // short return, medium return, long return
        // sub, gap open, gap extend
        algnCost = powell_3D_align( shortSeq
                                  , longSeq
                                  , mediumSeq
                                  , retShortSeq
                                  , retLongSeq
                                  , retMediumSeq
                                  , 1
                                  , 2
                                  , 1
                                  );

        printf("\n\nAligned 3d sequences:\n");
        dyn_char_print(retLongSeq);
        dyn_char_print(retMediumSeq);
        dyn_char_print(retShortSeq);

        printf("\nAlignment cost: %d\n", algnCost);

        printf("\n\n\n");

    }

    // algn_get_median_3d (dyn_character_t *seq1, dyn_character_t *seq2, dyn_character_t *seq3,
    //                cost_matrices_3d_t *m, dyn_character_t *sm)

    if (DO_2D) {
        freeCostMtx(costMtx2d, 1);  // 1 is 2d
        freeNWMtx(algn_mtxs2d);
    }

    if (DO_AFF) {
        freeCostMtx(costMtx2d_affine, 0);  // 1 is 2d
        freeNWMtx(algn_mtxs2dAffine);
    }

    // if (DO_3D) {
    //     freeCostMtx(costMtx3d, 0);  // 0 is !2d
    //     freeNWMtx(algn_mtxs3d);
    // }

    freeSeq(longSeq);
    freeSeq(shortSeq);
    freeSeq(mediumSeq);
    freeSeq(retLongSeq);
    freeSeq(retShortSeq);
    freeSeq(retMediumSeq);

    free(tcm);

    return 0;
}
