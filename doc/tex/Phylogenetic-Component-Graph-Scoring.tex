\documentclass[12pt]{article}
\usepackage[export]{adjustbox}
\usepackage{algorithm}
\usepackage{afterpage}
\usepackage[noend]{algpseudocode}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{bm}  % Define \bm{} to use bold math fonts
\usepackage{changepage}
\usepackage{csvsimple}
\usepackage{dcolumn}
\usepackage{flafter}  % Don't place floats before their definition
\usepackage{graphicx}
\usepackage{geometry}
\usepackage[utf8]{inputenc} %unicode support
\usepackage{lscape}
\usepackage{mathtools}
\usepackage{MnSymbol}
\usepackage{natbib}
\usepackage{setspace}
\usepackage{subfigure}
\usepackage{url}
\usepackage{setspace}
\usepackage{graphicx}
\graphicspath{{../diagrams/networks/}{../diagrams/display-trees/}}
\usepackage{flafter}  % Don't place floats before their definition
\usepackage{bm}  % Define \bm{} to use bold math fonts
\usepackage{pmboxdraw}
\usepackage{float}
\usepackage{fancyvrb}
%\usepackage{bera}
\usepackage[section]{placeins}
\usepackage{fullpage}
\bibliographystyle{cbe}
\citestyle{aa}
%\usepackage{algorithmic}
%\usepackage[vlined,algochapter,ruled]{algorithm2e}
%\usepackage[vlined,ruled]{algorithm2e}

%\SetKwComment{Comment}{$\triangleright\ $}{}

\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}
\algnewcommand\algorithmicswitch{\textbf{switch}}
\algnewcommand\algorithmiccase{\textbf{case}}
\algnewcommand\algorithmicdefault{\textbf{default}}
\algdef{SE}[SWITCH]{Switch}{EndSwitch}[1]{\algorithmicswitch\ #1\ \algorithmicdo}{\algorithmicend\ \algorithmicswitch}%
\algdef{SE}[CASE]{Case}{EndCase}[1]{\algorithmiccase\ #1}{\algorithmicend\ \algorithmiccase}%
\algdef{SE}[DEFAULT]{Default}{EndDefault}[1]{\algorithmicdefault\ #1}{\algorithmicend\ \algorithmicdefault}%
\algtext*{EndSwitch}%
\algtext*{EndCase}%
\algtext*{EndDefault}%
\renewcommand{\algorithmicensure}{\textbf{Result:}}


\title{Character optimization on phylogenetic soft-wired networks}
\author{Ward C. Wheeler$^1$, Alex Washburn$^2$, and Callan McGill$^3$\\
		%Richard Gilder Graduate School,\\
		$^1$Division of Invertebrate Zoology,\\
		American Museum of Natural History,\\
		Central Park West @ 79th Street,\\
		New York, NY 10024-5192,\\
		USA,\\
		wheeler@amnh.org\\
	    $^2$ Department of Computer Science\\
        City Univertsity of New York\\
        addres?\\
        $^3$ Bleh}
	%\date{}
\begin{document}

\maketitle
\newpage
\doublespace
\begin{abstract}
	A two-pass algorithmic procedure is described for the optimization of character data (e.g. qualitative, nucleic acid sequence) data
	on phylogenetic graphs.  The algorithms presented here are an extension of those developed for trees under the parsimony criterion
	and form the basis for phylogenetic network search procedures. 
\end{abstract}
\newpage
\tableofcontents
\newpage

%\doublespacing
\section{Introduction} \label{Introduction}
Phylogenetic analysis and the graphs structures it has been based on, has traditionally been limited to the analysis of trees.
Although more general graphs allowing for ``reticulation'' in cases of hybridization and horizontal gene flow have been proposed both informally and formally, historically, most analyses have focused on tree structures (reviewed in \citealp{Wheeler2012}).
Trees, informally, are characterized by all non-root vertices possessing a single parent, while networks exhibit internal nodes (again non-root) with multiple parents.
These ideas were placed in a formal context by \cite{moretetal2004} in their definition (described below) of phylogenetic networks.
We use this framework here.

Here we describe the process to determine the parsimony cost of a ``soft-wired network'' for a variety of character types.
By soft-wired we mean networks which are summaries of a set of individual ``display'' trees that can be generated by removing edges from the network \citep{Nakhlehetal2005, KannanandWheeler2012, Fischeretal2013}.
In a soft-wired network, individual characters have single parents, as opposed to those in ``hard-wired'' networks.  \cite{Nakhlehetal2005} proposed the first procedure for parsimony optimization for soft-wired networks that is based on character optimization on the display tree of minimum cost for that character. 
In order to avoid the trivial minimization this can produce, individual trees are applied to block of characters defined a priori.
An alternative to this approach wa proposed by \cite{Wheeler2015}, attaching a penalty cost to the addition of network edges, thereby avoiding the unbounded addition of network edges to improve overall cost.

The cost determination of an individual phylogenetic graph (tree or network) is the fundamental operation required upon which to identify heuristically optimal graphs.
Since tree and presumably (?--not sure this has been studied per se) network search are NP-hard optimizations; \citep{foulds1982, Day1987, Roch2006}, methods to identify useful solutions will employ a broad variety of combinatorial optimization procedures  (e.g. trajectory search, perturbation, genetic algorithm) and all of these will require cost determination of a given graph in comparison with a competitor.
Here we describe this fundamental cost determination.

\section{Definitions and Nomenclature}
Tree
Network (types )
Display trees

\subsection{Exact Character}

A character whose score is optimal for a display tree.

\subsection{Non-exact Character}

A character whose score is heuristically determined and not necessarily optimal for a display tree.

\subsection{Character Block}

A character block consists of a collection of characters which are to be treated as a single group which is optimized atomically across a phylogenetic network i.e. this group is to be assigned a single topology from the collection of network display trees.

\subsection{Character Sequence}

A character sequence is a collection of character blocks each of which may be treated non-atomically during optimization meaning that we can assign different display trees of a phylogenetic network to each block in the character sequence.

\subsection{Graph Traversal}

A graph traversal aims to take a phylogenetic network with character sequences assigned to each of the leaves and to assign character sequences to each

\subsection{Resolution}

During a postorder pass we we wish to assign to each node the lowest cost character sequence from its one or two children along with information that we propagate up the network including for instance the cost of the descendant subtrees, those leaf nodes in this resolution etc. 
Importantly a resolution makes sense only in the context of a display tree. 
We do not propagate information from a network node to its two parents (see Resolution Cache).

\subsection{Resolution Cache}

A resolution cache is a non-empty collection of resolutions. 
Such a collection represents each of the possible resolutions along each of the possible display trees that are descendant from the node.


\section{Labeling of a single graph} \label{Labelling of a single graph}
One of the fundamental procedures is in the labeling of individual graphs,  his is the determination of various aspects (including preliminary, final, and single assignments) of vertices and edges.   

The basic PCG graph is a forest of directed acyclic graphs (DAG). 
These DAGs may be trees in the sense of having vertices with (indegree, outdegree): (0, 1) the unique root, (1,0) leaves, and (1,2) ``internal'' vertices.; or networks adding (2,1) vertices as ``network'' vertices.
Individual components may have more than one root vertex.
All trees or networks are \textit{components} of a forest. 
A forest is a list of components, $F = [N]$, where $N = (V, E)$ (conventionally $V$ is a set of vertices and $E$ a set of edges).
One or more vertex in each component is a root. 
Vertices with indegree and outdegree 1 may be maintained for computational convenience, but would normally be contracted.
 
Following \cite{moretetal2004}, the above would be described as a ``model'' phylogenetic network.
This has two additional constraints.
First, that all edges must begin or end in a tree vertex (no network vertex to network vertex edges).  
Second,  the parents of a network vertex must, at least potentially, be contemporaneous. 
[Insert path conditions here]  
 
A less restrictive form of network (``reconstructable'') is defined by \cite{moretetal2004} with vertices (indegree, outdegree): 
(0, $\ge 1$) the unique root, (1, 0) leaves, and (1, $\ge$1) ``internal'' vertices, and networks adding ($\ge 2$, 1) vertices as ``network'' vertices.  For purposes of searching, outdegree of internal nodes is restricted to at most 2. Since edges may have zero length, networks may be output with vertices of outdegree $> 2$.


\section{Optimization of a single graph}\label{Optimization of a single graph}

Optimization is a function that takes a graph ($G$), here a forest $F$, and data ($D$) as inputs and returns a numerical value.  
This value can be referred to as its score ($S$)
\begin{eqnarray*}
	f & : &  \{\mathcal{F}, D\} \rightarrow \mathbb{R}\\
	g & : & \{  \mathbb{R},  \mathbb{R} \} \rightarrow \mathbb{R}
\end{eqnarray*}


\afterpage{
\newgeometry{margin=0.5in}

\begin{algorithm}
	\caption{Post-order preliminary scoring and assignment pass.}
	\label{Alg:post-order}
	\begin{algorithmic}[1]
		\Require{A phylogenetic graph component $\mathcal{T}$ with $n$ nodes. }
		\Require{Each leaf node $l \in \mathcal{T}$ decorated with a character sequence $C$ of length $m$. }
		\Require{A vector $\oplus$ of length $m$, where $\oplus_i : C_i \times C_i \to D_i$}
		\Ensure{Each internal node $v \in \mathcal{T}$ decorated with a post-order context containing possible character sequences of length $m$. }
		\Function{Post-Order}{$\textit{node}$}
		\If    {\Call{IsLeaf}{$\textit{node}$}}
		\State \Return
		\EndIf
		
		\Switch{\Call{GetChildren}{$\textit{node}$}}
		\Case{$\left( \textit{onlyChild} \right)$}
		\State $\textit{node}.\textit{resolutions} \gets$ \Call{GetResolutions}{$\textit{onlyChild}$}
		\EndCase
		\Case{$\left( \textit{leftChild}, \textit{rightChild} \right)$}
		\State $\textit{res} \gets$ \Call{GenerateResolutions}{$\textit{leftChild}, \textit{rightChild}$}
		\ForAll{$\textit{r} \in \textit{res}$}
		  \State $x \gets \textit{r.leftCharacterSequence}$ 
		  \State $y \gets \textit{r.rightCharacterSequence}$
		  \State $z \gets \emptyset$
		  \ForAll{$i \in [0, \; m-1]$}
		    \State $z_i \gets \oplus_i (x_i, y_i)$
		  \EndFor
		  $\textit{r.characterSequence} \gets z$
		\EndFor
		$\textit{node.resolutions} \gets \textit{res}$
		\EndCase
		\EndSwitch
		\EndFunction
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}
	\caption{Conveniently get the resolutions from an internal node or leaf node.}
	\label{Alg:get-resolutions}
	\begin{algorithmic}[1]
				
		\Function{GetResolutions}{$\textit{node}$}
		\If    {\Call{IsLeaf}{$\textit{node}$}}
		\State $\textit{i} \gets \Call{IndexOf}{\textit{node}}$ \Comment{$\mathcal{O}(1) \text{ access to } \textit{i} \in [0,\, m-1]$} 
		\State $\textit{r.leafBitVector} \gets \Call{SetBit}{\vec{0}, \textit{i}\,}$
		\State $\textit{r.characterSequence} \gets \textit{node.characterSequence}$
		\State \Return $\textit{r}$
		\Else
		\State \Return $\textit{node.resolutions}$
		\EndIf
		\EndFunction
		
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}
	\caption{Generate all valid resolutions given the two collection of child resolutions}
	\label{Alg:generate-resolutions}
	\begin{algorithmic}[1]
		\Function{GenerateResolutions}{$\textit{lhsNode}, \textit{rhsNode}$}
		\State $\textit{pairedResolutions} \gets \emptyset$

		\ForAll{$\textit{lhs} \in$ \Call{GetResolutions}{$\textit{lhsNode}$}}
		  \ForAll{$\textit{rhs} \in$ \Call{GetResolutions}{$\textit{rhsNode}$}}
		    \State $\textit{leavesInSubtree} \gets \textit{lhs.leafBitVector} \land \textit{rhs.leafBitVector}$
		    \If    {$\textit{leavesInSubtree} = \vec{0} $}
		      \State $\textit{r.leafBitVector} \gets \textit{leavesInSubtree}$
		      \State $\textit{r.lhsCharacterSequence} \gets \textit{lhs.characterSequence}$
		      \State $\textit{r.rhsCharacterSequence} \gets \textit{rhs.characterSequence}$
		      \State $\textit{pairedResolutions} \gets \textit{pairedResolutions} \cup \{r\}$
		    \EndIf    
		  \EndFor
		\EndFor
		
		\Switch{$($\Call{IsNetworkNode}{$\textit{leftChild}$}, \Call{IsNetworkNode}{$\textit{rightChild}$}$)$}
		\Case{$(\texttt{False}, \texttt{False})$}
		 \State \Return $\textit{pairedResolutions}$
		\EndCase
		\Case{$(\texttt{False}, \texttt{True})$}
		  \State \Return $\textit{pairedResolutions} \hspace{0.5em} \cup$ \Call{GetResolutions}{$\textit{lhsNode}$}
		\EndCase
		\Case{$(\texttt{True}, \texttt{False})$}
		  \State \Return $\textit{pairedResolutions} \hspace{0.5em} \cup$ \Call{GetResolutions}{$\textit{hsNode}$}
		\EndCase
		\Case{$(\texttt{True}, \texttt{True})$}
		  \State \Return $\textit{pairedResolutions} \hspace{0.3em} \cup \Call{GetResolutions}{\textit{lhsNode}} \cup \Call{GetResolutions}{\textit{rhsNode}}$
		\EndCase
		\EndSwitch
		\EndFunction
	\end{algorithmic}
\end{algorithm}
\clearpage

\begin{algorithm}
	\caption{Determine the optimal rooting edge for each non-exact character}
	\label{Alg:generate-resolutions}
	\begin{algorithmic}[1]
		\Require{A phylogenetic graph component $\mathcal{T}$ with $n$ nodes. }
		\Require{Each node $v \in \mathcal{T}$ decorated with a post-order context for each $k$ non-exact characters.}
		\Require{A vector $\oplus$ of length $k$, where $\oplus_i : C_i \times C_i \to D_i$}
		\Ensure{Each edge $e \in \mathcal{T}$ decorated with a post-order context for each $k$ non-exact characters.}
		\Function{NonExactCharacterRerooting}{$\mathcal{T}$}
		
		\State $R \gets \Call{rootNodes}{\mathcal{T}}$
		\State $\textit{rootEdges} \gets \bigcup\limits_{r\; \in\; R} \Call{incedentEdges}{r}$
		\State $\textit{unrootedEdges} \gets \Call{edgeSet}{\mathcal{T}} \backslash \textit{rootEdges}$
		\ForAll{$\textit{edge} \in \textit{unrootedEdges}$}
		  \State $(\textit{nodeL}, \textit{nodeR}) \gets \Call{ConnectedNodes}{\textit{edge}}$
		  \State $\textit{lhs} \gets \Call{memoSubtreeQuery}{\textit{edge}, \textit{nodeL}}$
		  \State $\textit{rhs} \gets \Call{memoSubtreeQuery}{\textit{edge}, \textit{nodeR}}$
		  \State $\textit{edge.resolutions} \gets \Call{GenerateResolutions}{\textit{lhs}, \textit{rhs}}$
		\EndFor
		
		\State $\textit{optimalTopologies} \gets \emptyset$
		\State $\textit{optimalRootings}   \gets \emptyset$
		\ForAll{$i \in [0, \; b-1]$}
		    \State $\textit{bestCost} \gets \infty$
		    \State $\textit{bestFoci} \gets \texttt{NULL}$
		    \State $\textit{bestTree} \gets \texttt{NULL}$
		    
			\ForAll{$topology \in \textit{displayTrees}$}
			  \State $\textit{topologyCost}   \gets 0$
			  \State $\textit{characterEdges} \gets \emptyset$			  
			  
			  \ForAll{$j \in [0, \; k-1]$}
			    \If    {$C_j \not\in B_i$} \Comment{Skip characters not in this block}
			    \State $\texttt{Break}$
			    \EndIf
		        \State $\textit{bestEdges} \gets \emptyset$
		        \State $\textit{edgeCost} \gets \infty$
			    \ForAll{$edge \in \textit{topology}$}
			      \State $resolution \gets edge.resolutions_{topology}$
			      \State $cost \gets \Call{SubtreeCost}{resolution}$
			      \If {$cost < \textit{edgeCost}$}
			        \State $\textit{bestEdges} \gets \left\{ edge \right\}$
			        \State $\textit{edgeCost} \gets cost$
			      \ElsIf{$cost = \textit{edgeCost}$}
				      \State $bestEdges \gets bestEdges \cup \left\{ edge \right\}$
			      \EndIf
			    \EndFor
			 	\State $topologyCost \gets topologyCost + edgeCost$
			 	\State $characterEdges_j \gets bestEdges$
			 	
              \EndFor
			    \If {$topologyCost < bestCost$}
                  \State $bestCost \gets bestTree$
                  \State $bestFoci \gets characterEdges$
                  \State $bestTree \gets topology$
				\EndIf

			\EndFor
			\State $optimalTopologies_b \gets bestTree$
			\ForAll{$j \in [0, \; k-1]$}
			  \If{$optimalRootings_j \ne \emptyset$}
			    \State $optimalRootings_j \gets bestFoci_j$
			  \EndIf
			\EndFor

		\EndFor		
		
		\State \Return $(optimalTopologies, optimalRootings)$

		\EndFunction
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}
	\caption{Determine the optimal rooting edge for each non-exact character}
	\label{Alg:generate-resolutions}
	\begin{algorithmic}[1]
		\Function{memoSubtreeQuery}{$\textit{edge}, \textit{node}$}
		\If    {$\textit{edge} \in \Call{ParentalEdges}{\textit{node}}$}
		  \State \Return $\Call{GetResolutions}{\textit{node}}$
		\EndIf
		\State $\left\{ \textit{edgeA}, \textit{edgeB} \right\} \gets \Call{incedentEdges}{\textit{node}} \backslash \left\{ \textit{edge} \right\}$
		\State $\textit{nodeL} \gets \Call{getOppositeNode}{ \textit{edgeL}, \textit{node} }$
		\State $\textit{nodeR} \gets \Call{getOppositeNode}{ \textit{edgeR}, \textit{node} }$
		\State $\textit{lhs} \gets \Call{memoSubtreeQuery}{\textit{edgeR},\textit{nodeL}}$
		\State $\textit{rhs} \gets \Call{memoSubtreeQuery}{\textit{edgeL},\textit{nodeR}}$
		\State \Return $\Call{GenerateResolutions}{\textit{lhs}, \textit{rhs}}$
		\EndFunction
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}
	\caption{Determine the additional cost of network edges}
	\label{Alg:network-edge-cost}
	\begin{algorithmic}[1]
		\Function{networkEdgeCost}{$\mathcal{T}, \textsc{topologyRerootings}$}
		
		\State $topologyCosts \gets \emptyset$
		\ForAll{$t \in \Call{DisplayTrees}{\mathcal{T}}$}
		  \State $topologyCosts_{t} \gets \mathcal{T}.root.resolutions_{t} + topologyRerootings_t$
		\EndFor
		
		\State $parsimoniousTopology \gets \min\limits_{t\; \in\; \Call{DisplayTrees}{\mathcal{T}}}$ $topologyCosts_{t}$
		
		\State $blockTopologies \gets \emptyset$
		\State $blockCosts      \gets \emptyset$
		\ForAll{$b \in B$}
		  \State $minT \gets \min\limits_{t\; \in\; \Call{DisplayTrees}{\mathcal{T}}} \mathcal{T}.root.resolutions_{t}.blocks_{b} + topologyRerootings_{t}.blocks_{b}$
          \State $blockTopologies_{b} \gets minT$
          \State $blockCosts_{b}      \gets \mathcal{T}.root.resolutions_{minT}.blocks_{b} + topologyRerootings_{minT}.blocks_{b}$
		\EndFor
		
		\State $requisiteEdges \gets \bigcup\limits_{t \in blockTopologies} \Call{EdgeSet}{t}$
		
		\If    {$\Call{NetworkEdgeSet}{\mathcal{T}} \backslash requisiteEdges$}
		   \State \Return $\infty$
		\EndIf
		
		\State $networkEdgeCost \gets 0$
		\State $pEdges \gets \Call{NetworkEdgeSet}{parsimoniousTopology}$
		\State $edgeCount \gets |\Call{EdgeSet}{\mathcal{T}}|$
		\ForAll{$b \in B$}
		  \State $bEdges \gets \Call{NetworkEdgeSet}{blockTopologies_b}$
		  \State $extraEdges \gets |pEdges \backslash bEdges |$
		  \State $networkEdgeCost \gets networkEdgeCost + \frac{extraEdges \;*\; blockCosts_b}{edgeCount}$
		\EndFor
		
		\State $characterCost \gets \sum\limits_{b\; \in\; B} blockCosts_{b}$
		
		\State $rootingCost \gets \sum\limits_{r\; \in\; \Call{RootSet}{\mathcal{T}}} \Call{RootingCost}{r}$
		
		\State $graphCost \gets rootingCost + networkEdgeCost + characterCost$

		\State \Return $(graphCost, blockTopologies)$
		\EndFunction
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}
	\caption{Assign final states to the soft-wire graph}
	\label{Alg:pre-order-traversal}
	\begin{algorithmic}[1]
		\Function{PreOrder}{$\mathcal{T}, \textit{blockTopologies}, optimalRootings$}
		
		\ForAll{$b \in B$}
		  \State $t \gets blockTopologies_{b}$
		  \State $blockRoot \gets t.root$
		  \State $exactCharacters \gets \emptyset$
		  \State $nonExactCharacters \gets \emptyset$
		  \ForAll{$character \in b$}
		    \If{$\Call{IsExact}{character}$}
		      \State $exactCharacters \gets character$
		    \Else
		      \State $nonExactCharacters \gets character$
		    \EndIf
		  \EndFor
		  \State $\Call{InitializeRootExactCharacters}{blockRoot, exactCharacters}$
		  \ForAll{$child \in \Call{GetChildren}{blockRoot}$}
		    \State $\Call{PreOrderExact}{exactCharacters, blockRoot, child}$
		  \EndFor
		  \ForAll{$character \in nonExactCharacters$}
		    \State $(charRootDatum, charRootingEdge) \gets optimalRootings_{character}$
		    \State $(lhs, rhs) \gets \Call{GetIncidentNodes}{charRootingEdge}$
		    \State $charRootFinal \gets \Call{InitializeRootNonExactCharacter}{charRootDatum}$
		    \State $\Call{PreOrderNonExact}{character, charRootFinal, lhs}$
		    \State $\Call{PreOrderNonExact}{character, charRootFinal, rhs}$
		  \EndFor

		\EndFor
		\EndFunction
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}
	\caption{Assign final states to the soft-wire graph}
	\label{Alg:pre-order-traversal}
	\begin{algorithmic}[1]
		\Require{A vector $\otimes$ of length $k$, where $\otimes_i : D_i \times C_i \to D_i$}
		\Function{PreOrderExact}{$\textit{characters}, \textit{parent}, \textit{node}$}
		  \ForAll{$c \in characters$}
		    \State $node.final_c \gets parent.final_c \;\;\otimes_c\;\; node.preliminary_c$
		  \EndFor
		  \ForAll{$child \in \Call{GetChildren}{node}$}
		    \State $\Call{PreOrderExact}{characters, node, child}$
		  \EndFor
		\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
	\caption{Assign final states to the soft-wire graph}
	\label{Alg:pre-order-traversal}
	\begin{algorithmic}[1]
		\Require{A vector $\otimes$ of length $k$, where $\otimes_i : D_i \times C_i \to D_i$}
		\Function{PreOrderNonExact}{$\textit{c}, \textit{parent}, \textit{node}$}
		\State $node.final_c \gets parent.final_c \;\;\otimes_c\;\; node.preliminary_c$
		\ForAll{$child \in \Call{GetChildren}{node}$}
		  \State $\Call{PreOrderNonExact}{c, node, child}$
		\EndFor
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\restoregeometry
}


\section*{Acknowledgments}
The author would like to thank DARPA SIMPLEX N66001-15-C-4039, and Robert J. Kleberg Jr. and Helen C. Kleberg foundation grant ``Mechanistic Analyses of Pancreatic Cancer Evolution'' and the American Museum of Natural History for financial support. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%     please remove the " % " symbol from \centerline{\includegraphics{fig01.eps}}
%     as it may ignore the figures.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%\bibliography{big-refs-3.bib}
\bibliography{big-refs-3.bib}
%\bibliography{/home/ward/Dropbox/Work_stuff/manus/big-refs-3.bib}
\end{document}
