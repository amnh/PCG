\documentclass[11pt]{article}
\usepackage[export]{adjustbox}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{bm}  % Define \bm{} to use bold math fonts
\usepackage{csvsimple}
\usepackage{dcolumn}
\usepackage{flafter}  % Don't place floats before their definition
\usepackage{graphicx}
\usepackage{geometry}
\usepackage[utf8]{inputenc} %unicode support
\usepackage{lscape}
\usepackage{mathtools}
\usepackage{MnSymbol}
\usepackage{natbib}
\usepackage{setspace}
\usepackage{subfigure}
\usepackage{tabularx}
\usepackage{url}
\usepackage{setspace}
\usepackage{graphicx}
\graphicspath{{../diagrams/networks/}{../diagrams/display-trees/}}
\usepackage{subfigure}
\usepackage{lscape}
\usepackage{flafter}  % Don't place floats before their definition
\usepackage{bm}  % Define \bm{} to use bold math fonts
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{MnSymbol}
\usepackage{url}
\usepackage{natbib}
\usepackage{pmboxdraw}
\usepackage{float}
\usepackage{fancyvrb}
\usepackage{bera}
\usepackage[section]{placeins}
%\usepackage{fullpage}
\bibliographystyle{cbe}
\citestyle{aa}
%\usepackage{algorithmic}
%\usepackage[vlined,algochapter,ruled]{algorithm2e}
%\usepackage[vlined,ruled]{algorithm2e}
\usepackage{listings}% http://ctan.org/pkg/listings
\lstset{
  basicstyle=\ttfamily,
  mathescape
}
%\SetKwComment{Comment}{$\triangleright\ $}{}

\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}
\algnewcommand\algorithmicswitch{\textbf{switch}}
\algnewcommand\algorithmiccase{\textbf{case}}
\algnewcommand\algorithmicdefault{\textbf{default}}
\algdef{SE}[SWITCH]{Switch}{EndSwitch}[1]{\algorithmicswitch\ #1\ \algorithmicdo}{\algorithmicend\ \algorithmicswitch}%
\algdef{SE}[CASE]{Case}{EndCase}[1]{\algorithmiccase\ #1}{\algorithmicend\ \algorithmiccase}%
\algdef{SE}[DEFAULT]{Default}{EndDefault}[1]{\algorithmicdefault\ #1}{\algorithmicend\ \algorithmicdefault}%
\algtext*{EndSwitch}%
\algtext*{EndCase}%
\algtext*{EndDefault}%
\renewcommand{\algorithmicensure}{\textbf{Result:}}

%ROOT PRIORS?
%Add Giribet and Wheeler arth, ratchet cite, Arango sea spiders

\title{Algorithmic Descriptions and Pseudo-Code for Phylogenetic Component Graphs}
\author{Ward C. Wheeler\\
		%Richard Gilder Graduate School,\\
		Division of Invertebrate Zoology,\\
		American Museum of Natural History,\\
		Central Park West @ 79th Street,\\
		New York, NY 10024-5192,\\
		USA,\\
		wheeler@amnh.org}
	%\date{}
\begin{document}

\maketitle
\begin{abstract}
	Algorithmic Descriptions and Pseudo-Code for Phylogenetic Component Graphs (PCG) code base.
\end{abstract}
%\newpage
\tableofcontents
%\newpage

%\doublespacing
\section{Introduction} \label{Introduction}
This document contains the descriptions and pseudo-code for core  Phylogenetic Component Graphs (PCG) algorithms.  
This is designed to serve both as documentation for the code and a development tool. 
We have tried to keep the style as consistent as possible, Functional-type statements (\textit{e.g.} map and fold) and structures (\textit{e.g.} lists, tuples) are employed.

We should expand this section to include a motivation for phylogenetic networks, a brief history of their development by biologists and mathematicians, and give a brief summary of our unique construction and contributions.

\section{Definitions and Nomenclature}

\subsection{Exact Character}

A character whose score is optimal for a display tree.

\subsection{Non-exact Character}

A character whose score is heuristically determined and not necessarily optimal for a display tree.

\subsection{Character Block}

A character block consists of a collection of characters which are to be treated as a single group which is optimized atomically across a phylogenetic network i.e. this group is to be assigned a single topology from the collection of network display trees.

\subsection{Character Sequence}

A character sequence is a collection of character blocks each of which may be treated non-atomically during optimization meaning that we can assign different display trees of a phylogenetic network to each block in the character sequence.

\subsection{Graph Traversal}

A graph traversal aims to take a phylogenetic network with character sequences assigned to each of the leaves and to assign character sequences to each

\subsection{Resolution}

During a postorder pass we we wish to assign to each node the lowest cost character sequence from its one or two children along with information that we propagate up the network including for instance the cost of the descendant subtrees, those leaf nodes in this resolution etc. 
Importantly a resolution makes sense only in the context of a display tree. 
We do not propagate information from a network node to its two parents (see Resolution Cache).

\subsection{Resolution Cache}

A resolution cache is a non-empty collection of resolutions. 
Such a collection represents each of the possible resolutions along each of the possible display trees that are descendant from the node.


\section{Labeling of a single graph} \label{Labelling of a single graph}
One of the fundamental procedures is in the labeling of individual graphs,  his is the determination of various aspects (including preliminary, final, and single assignments) of vertices and edges.   

The basic PCG graph is a forest of directed acyclic graphs (DAG). 
These DAGs may be trees in the sense of having vertices with (indegree, outdegree): (0, 1) the unique root, (1,0) leaves, and (1,2) ``internal'' vertices.; or networks adding (2,1) vertices as ``network'' vertices.
Individual components may have more than one root vertex.
All trees or networks are \textit{components} of a forest. 
A forest is a list of components, $F = [N]$, where $N = (V, E)$ (conventionally $V$ is a set of vertices and $E$ a set of edges).
One or more vertex in each component is a root. 
Vertices with indegree and outdegree 1 may be maintained for computational convenience, but would normally be contracted.
 
Following \cite{moretetal2004}, the above would be described as a ``model'' phylogenetic network.
This has two additional constraints.
First, that all edges must begin or end in a tree vertex (no network vertex to network vertex edges).  
Second,  the parents of a network vertex must, at least potentially, be contemporaneous. 
[Insert path conditions here]  
 
A less restrictive form of network (``reconstructable'') is defined by \cite{moretetal2004} with vertices (indegree, outdegree): 
(0, $\ge 1$) the unique root, (1, 0) leaves, and (1, $\ge$1) ``internal'' vertices, and networks adding ($\ge 2$, 1) vertices as ``network'' vertices.  For purposes of searching, outdegree of internal nodes is restricted to at most 2. Since edges may have zero length, networks may be output with vertices of outdegree $> 2$.

\begin{algorithm}
	\caption{Post-order preliminary scoring and assignment pass.}
	\label{Alg:post-order}
	\begin{algorithmic}[1]
		\Require{A phylogenetic graph component $\mathcal{T}$ with $n$ nodes. }
		\Require{Each leaf node $l \in \mathcal{T}$ decorated with a character sequence $C$ of length $m$. }
		\Require{A vector $\oplus$ of length $m$, where $\oplus_i : C_i \times C_i \to D_i$}
		\Ensure{Each internal node $v \in \mathcal{T}$ decorated with a post-order context containing possible character sequences of length $m$. }
		\Function{Post-Order}{$\textit{node}$}
		\If    {\Call{IsLeaf}{$\textit{node}$}}
		\State \Return
		\EndIf
		
		\Switch{\Call{GetChildren}{$\textit{node}$}}
		\Case{$\left( \textit{onlyChild} \right)$}
		\State $\textit{node}.\textit{resolutions} \gets$ \Call{GetResolutions}{$\textit{onlyChild}$}
		\EndCase
		\Case{$\left( \textit{leftChild}, \textit{rightChild} \right)$}
		\State $\textit{lhs} \gets$ \Call{GetResolutions}{$\textit{leftChild}$}
		\State $\textit{rhs} \gets$ \Call{GetResolutions}{$\textit{rightChild}$}
		\State $\textit{res} \gets$ \Call{GenerateResolutions}{$\textit{lhs, rhs}$}
		\EndCase
		\EndSwitch
		\ForAll{$r \in \textit{res}$}
		  \State $x \gets r.leftCharacterSequence$ 
		  \State $y \gets r.rightCharacterSequence$ 
		  \State $z \gets \emptyset$
		  \ForAll{$i \in [0, \; m-1]$}
		    \State $z_i \gets \oplus_i (x_i, y_i)$
		  \EndFor
		  $r.characterSequence \gets z$
		\EndFor
		\EndFunction
		
		\Function{GetResolutions}{$\textit{node}$}
		\If    {\Call{IsLeaf}{$\textit{node}$}}
		\State \Return \Call{SingletonResolution}{$\textit{node.characterSequence}$}
		\Else
		\State \Return $\textit{node.resolutions}$
		\EndIf
		\EndFunction
		
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Generate all valid resolutions given the two collection of child resolutions}
	\label{Alg:generate-resolutions}
	\begin{algorithmic}[1]
		\Function{GenerateResolutions}{$\textit{lhs}, \textit{rhs}$}
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\section{Optimization of a single graph}\label{Optimization of a single graph}

Optimization is a function that takes a graph ($G$), here a forest $F$, and data ($D$) as inputs and returns a numerical value.  
This value can be referred to as its score ($S$)
 	\begin{eqnarray*}
 		f & : &  \{\mathcal{F}, D\} \rightarrow \mathbb{R}\\
		g & : & \{  \mathbb{R},  \mathbb{R} \} \rightarrow \mathbb{R}
	 \end{eqnarray*}
 

\newpage
\singlespacing
\bibliography{/users/ward/home/biblio/ward_new}
%\bibliography{ward_new}

%cost of root for pars = insert all characters, good first aapprox

%
%Algorithm basic template
%	\begin{algorithm}
%		\caption{Blah}
%		\label{alg:Blah}
%		\SetAlgoLined
%		\KwData{Input data $D$}
%		\KwResult{Blah}
%		\Comment{Blah Comment}
%		\Return{Bleh} 					
%	\end{algorithm}

\end{document}
