#NEXUS[!Example from Felsenstein's PROTPARS documentation][This example demonstrates the use of PAUP to perform ananalysis equivalent to Felsenstein's PROTPARS program fromthe PHYLIP package.  Stepmatrices are constructed whichspecify the minimum number of amino acid replacementsrequired to convert one amino acid to another.  (Silentnucleotide substitutions are "free".)Note the special treatment for serine, whose codons are notadjacent in the genetic code.  The two forms of serine arerepresented as "1" and "2", and "S" is then treated as anambiguity code for these two states.  The "1" and "2" symbolsmust therefore be added to the standard protein-formatsymbols (the single-letter amino acid codes).  Also, gapsare treated as additional character states by Felsenstein'sprogram, hence the "gapmode=newstate", which overrides thedefault of "gapmode=missing".]begin data;	dimensions ntax=5 nchar=10;	format datatype=protein gap=-		   symbols="12" equate="S={12}";	options gapmode=newstate;	matrixAlpha	ABCDEFGHIKBeta	AB--EFGHIKGamma	?BCDSFG*??Delta	CIKDEFGHIKEpsilon	DIKDEFGHIK	;endblock;begin assumptions;	usertype protpars = 23	[This matrix gives the minimum number of amino acid	replacement substitutions needed to convert one amino	acid to another, based on the genetic code used in	nuclear genes of most organisms and chloroplast genes	in plants).  It was computed using a program written	by DLS.	]	     A C D E F G H I K L M N P Q R 1 2 T V W Y * -	[A]  0 2 1 1 2 1 2 2 2 2 2 2 1 2 2 1 2 1 1 2 2 2 3	[C]  2 0 2 2 1 1 2 2 2 2 2 2 2 2 1 1 1 2 2 1 1 1 3	[D]  1 2 0 1 2 1 1 2 2 2 2 1 2 2 2 2 2 2 1 2 1 2 3	[E]  1 2 1 0 2 1 2 2 1 2 2 2 2 1 2 2 2 2 1 2 2 1 3	[F]  2 1 2 2 0 2 2 1 2 1 2 2 2 2 2 1 2 2 1 2 1 2 3	[G]  1 1 1 1 2 0 2 2 2 2 2 2 2 2 1 2 1 2 1 1 2 1 3	[H]  2 2 1 2 2 2 0 2 2 1 2 1 1 1 1 2 2 2 2 2 1 2 3	[I]  2 2 2 2 1 2 2 0 1 1 1 1 2 2 1 2 1 1 1 2 2 2 3	[K]  2 2 2 1 2 2 2 1 0 2 1 1 2 1 1 2 2 1 2 2 2 1 3	[L]  2 2 2 2 1 2 1 1 2 0 1 2 1 1 1 1 2 2 1 1 2 1 3	[M]  2 2 2 2 2 2 2 1 1 1 0 2 2 2 1 2 2 1 1 2 3 2 3	[N]  2 2 1 2 2 2 1 1 1 2 2 0 2 2 2 2 1 1 2 3 1 2 3	[P]  1 2 2 2 2 2 1 2 2 1 2 2 0 1 1 1 2 1 2 2 2 2 3	[Q]  2 2 2 1 2 2 1 2 1 1 2 2 1 0 1 2 2 2 2 2 2 1 3	[R]  2 1 2 2 2 1 1 1 1 1 1 2 1 1 0 2 1 1 2 1 2 1 3	[1]  1 1 2 2 1 2 2 2 2 1 2 2 1 2 2 0 2 1 2 1 1 1 3	[2]  2 1 2 2 2 1 2 1 2 2 2 1 2 2 1 2 0 1 2 2 2 2 3	[T]  1 2 2 2 2 2 2 1 1 2 1 1 1 2 1 1 1 0 2 2 2 2 3	[V]  1 2 1 1 1 1 2 1 2 1 1 2 2 2 2 2 2 2 0 2 2 2 3	[W]  2 1 2 2 2 1 2 2 2 1 2 3 2 2 1 1 2 2 2 0 2 1 3	[Y]  2 1 1 2 1 2 1 2 2 2 3 1 2 2 2 1 2 2 2 2 0 1 3	[*]  2 1 2 1 2 1 2 2 1 1 2 2 2 1 1 1 2 2 2 1 1 0 3	[-]  3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0	;	typeset *a = protpars:all;endblock;